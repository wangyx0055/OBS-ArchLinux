diff -Naur a/configure.ac b/configure.ac
--- a/configure.ac	2015-10-13 04:35:02.908853472 +0000
+++ b/configure.ac	2015-10-13 04:33:55.158853946 +0000
@@ -132,6 +132,7 @@
 AC_ARG_ENABLE(pltbrowser, [AS_HELP_STRING([--enable-pltbrowser      ], [build playlist browser gui plugin (default: auto)])], [enable_pltbrowser=$enableval], [enable_pltbrowser=yes])
 AC_ARG_ENABLE(sc68, [AS_HELP_STRING([--enable-sc68     ], [build sc68 Atari ST and Amiga music player (default: auto)])], [enable_sc68=$enableval], [enable_sc68=yes])
 AC_ARG_ENABLE(abstract_socket, [AS_HELP_STRING([--enable-abstract-socket      ], [use abstract UNIX socket for IPC (default: disabled)])], [enable_abstract_socket=$enableval], [enable_abstract_socket=no])
+AC_ARG_ENABLE(statusnotifier, [AS_HELP_STRING([--enable-statusnotifier], [KDE status notifier plugin for tray icon (default: disabled)])], [enable_statusnotifier=$enableval], [enable_statusnotifier=yes])
 
 AS_IF([test "${enable_staticlink}" != "no"], [
     AC_DEFINE_UNQUOTED([STATICLINK], [1], [Define if building static version])
@@ -796,7 +797,20 @@
     HAVE_SC68=yes
 ])
 
-PLUGINS_DIRS="plugins/liboggedit plugins/libmp4ff plugins/libparser plugins/lastfm plugins/mp3 plugins/vorbis plugins/flac plugins/wavpack plugins/sndfile plugins/vfs_curl plugins/cdda plugins/gtkui plugins/alsa plugins/ffmpeg plugins/hotkeys plugins/oss plugins/artwork plugins/adplug plugins/ffap plugins/sid plugins/nullout plugins/supereq plugins/vtx plugins/gme plugins/pulse plugins/notify plugins/musepack plugins/wildmidi plugins/tta plugins/dca plugins/aac plugins/mms plugins/shellexec plugins/shellexecui plugins/dsp_libsrc plugins/m3u plugins/vfs_zip plugins/converter plugins/dumb plugins/shn plugins/ao plugins/mono2stereo plugins/alac plugins/wma plugins/pltbrowser plugins/coreaudio plugins/sc68"
+AS_IF([test "${enable_statusnotifier}" != "no"], [
+    echo "Checking statusnotifier deps..."
+    AS_IF([test "${enable_staticlink}" != "no"], [
+        HAVE_STATUSNOTIFIER=yes
+        STATUSNOTIFIER_DEPS_CFLAGS="-I../../${LIB}/gtk-3.0.0/include/gio-unix-2.0/ -I../../${LIB}/gtk-3.0.0/include/gdk-pixbuf-2.0 -I../../${LIB}/gtk-3.0.0/include/glib-2.0 -I../../${LIB}/gtk-3.0.0/lib/glib-2.0/include"
+        STATUSNOTIFIER_DEPS_LIBS="-L${GTK_ROOT_300}/lib -lgio-2.0 -lgdk_pixbuf-2.0 -lgobject-2.0 -lglib-2.0"
+        AC_SUBST(STATUSNOTIFIER_DEPS_CFLAGS)
+        AC_SUBST(STATUSNOTIFIER_DEPS_LIBS)
+    ], [
+        PKG_CHECK_MODULES(STATUSNOTIFIER_DEPS, glib-2.0 >= 2.26 gio-2.0 gdk-pixbuf-2.0, HAVE_STATUSNOTIFIER=yes, HAVE_STATUSNOTIFIER=no)
+    ])
+])
+
+PLUGINS_DIRS="plugins/liboggedit plugins/libmp4ff plugins/libparser plugins/lastfm plugins/mp3 plugins/vorbis plugins/flac plugins/wavpack plugins/sndfile plugins/vfs_curl plugins/cdda plugins/gtkui plugins/alsa plugins/ffmpeg plugins/hotkeys plugins/oss plugins/artwork plugins/adplug plugins/ffap plugins/sid plugins/nullout plugins/supereq plugins/vtx plugins/gme plugins/pulse plugins/notify plugins/musepack plugins/wildmidi plugins/tta plugins/dca plugins/aac plugins/mms plugins/shellexec plugins/shellexecui plugins/dsp_libsrc plugins/m3u plugins/vfs_zip plugins/converter plugins/dumb plugins/shn plugins/ao plugins/mono2stereo plugins/alac plugins/wma plugins/pltbrowser plugins/coreaudio plugins/sc68 plugins/statusnotifier"
 
 AM_CONDITIONAL(APE_USE_YASM, test "x$APE_USE_YASM" = "xyes")
 AM_CONDITIONAL(HAVE_VORBIS, test "x$HAVE_VORBISPLUGIN" = "xyes")
@@ -861,6 +875,7 @@
 AM_CONDITIONAL(PORTABLE, test "x$PORTABLE" = "xyes")
 AM_CONDITIONAL(PORTABLE_FULL, test "x$PORTABLE_FULL" = "xyes")
 AM_CONDITIONAL(USE_ABSTRACT_SOCKET_NAME, test "x$USE_ABSTRACT_SOCKET_NAME" = "xyes")
+AM_CONDITIONAL(HAVE_STATUSNOTIFIER, test "x$HAVE_STATUSNOTIFIER" = "xyes")
 AM_CONDITIONAL(HAVE_SSE2, test "${HAVE_SSE2}")
 
 AC_SUBST(PLUGINS_DIRS)
@@ -916,6 +931,7 @@
 plugins/pltbrowser/Makefile
 plugins/sc68/Makefile
 plugins/coreaudio/Makefile
+plugins/statusnotifier/Makefile
 intl/Makefile
 po/Makefile.in
 deadbeef.desktop
@@ -994,6 +1010,7 @@
 PRINT_PLUGIN_INFO([wma],[WMA plugin],[test "x$HAVE_WMA" = "xyes"])
 PRINT_PLUGIN_INFO([pltbrowser],[playlist browser gui plugin],[test "x$HAVE_PLTBROWSER" = "xyes"])
 PRINT_PLUGIN_INFO([sc68],[sc68 Atari ST And Amiga player],[test "x$HAVE_SC68" = "xyes"])
+PRINT_PLUGIN_INFO([statusnotifier],[plugin for KDE tray icon support],[test "x$HAVE_STATUSNOTIFIER" = "xyes"])
 
 echo
 
diff -Naur a/configure.ac.rej b/configure.ac.rej
--- a/configure.ac.rej	1970-01-01 00:00:00.000000000 +0000
+++ b/configure.ac.rej	2015-10-13 04:33:19.775520860 +0000
@@ -0,0 +1,10 @@
+--- configure.ac
++++ configure.ac
+@@ -869,6 +883,7 @@ AM_CONDITIONAL(STATICLINK, test "x$STATICLINK" = "xyes")
+ AM_CONDITIONAL(PORTABLE, test "x$PORTABLE" = "xyes")
+ AM_CONDITIONAL(PORTABLE_FULL, test "x$PORTABLE_FULL" = "xyes")
+ AM_CONDITIONAL(USE_ABSTRACT_SOCKET_NAME, test "x$USE_ABSTRACT_SOCKET_NAME" = "xyes")
++AM_CONDITIONAL(HAVE_STATUSNOTIFIER, test "x$HAVE_STATUSNOTIFIER" = "xyes")
+ 
+ AC_SUBST(PLUGINS_DIRS)
+ 
diff -Naur a/plugins/gtkui/gtkui.c b/plugins/gtkui/gtkui.c
--- a/plugins/gtkui/gtkui.c	2015-10-13 04:35:03.045520138 +0000
+++ b/plugins/gtkui/gtkui.c	2015-10-13 04:33:19.775520860 +0000
@@ -75,6 +75,7 @@
 // main widgets
 GtkWidget *mainwin;
 GtkWidget *searchwin;
+int gtkui_override_statusicon = 0;
 GtkStatusIcon *trayicon;
 GtkWidget *traymenu;
 
@@ -288,6 +289,20 @@
     return FALSE;
 }
 
+static gboolean
+show_traymenu_cb (gpointer data) {
+    if (!traymenu) {
+        traymenu = create_traymenu ();
+    }
+    gtk_menu_popup (GTK_MENU (traymenu), NULL, NULL, NULL, NULL, 0, gtk_get_current_event_time());
+    return FALSE;
+}
+
+static void
+show_traymenu (void) {
+    g_idle_add (show_traymenu_cb, NULL);
+}
+
 void
 mainwin_toggle_visible (void) {
     int iconified = gdk_window_get_state(gtk_widget_get_window(mainwin)) & GDK_WINDOW_STATE_ICONIFIED;
@@ -514,6 +529,9 @@
 static gboolean
 gtkui_update_status_icon (gpointer unused) {
     int hide_tray_icon = deadbeef->conf_get_int ("gtkui.hide_tray_icon", 0);
+    if (gtkui_override_statusicon) {
+        hide_tray_icon = 1;
+    }
     if (hide_tray_icon && !trayicon) {
         return FALSE;
     }
@@ -570,6 +588,12 @@
 }
 
 static void
+override_builtin_statusicon (int override) {
+    gtkui_override_statusicon = override;
+    g_idle_add (gtkui_update_status_icon, NULL);
+}
+
+static void
 gtkui_hide_status_icon () {
     if (trayicon) {
         g_object_set (trayicon, "visible", FALSE, NULL);
@@ -1689,4 +1713,7 @@
     .get_cover_art_primary = get_cover_art_primary,
     .get_cover_art_thumb = get_cover_art_thumb,
     .cover_get_default_pixbuf = cover_get_default_pixbuf,
+    .mainwin_toggle_visible = mainwin_toggle_visible,
+    .show_traymenu = show_traymenu,
+    .override_builtin_statusicon = override_builtin_statusicon,
 };
diff -Naur a/plugins/gtkui/gtkui_api.h b/plugins/gtkui/gtkui_api.h
--- a/plugins/gtkui/gtkui_api.h	2015-10-13 04:35:03.045520138 +0000
+++ b/plugins/gtkui/gtkui_api.h	2015-10-13 04:33:19.775520860 +0000
@@ -37,11 +37,15 @@
 // please visit the following page:
 // http://github.com/Alexey-Yakovenko/deadbeef/wiki/Porting-GUI-plugins-to-deadbeef-from-0.5.x-to-0.6.0
 
+#if defined(GTK_CHECK_VERSION)
 #if GTK_CHECK_VERSION(3,0,0)
 #define DDB_GTKUI_PLUGIN_ID "gtkui3_1"
 #else
 #define DDB_GTKUI_PLUGIN_ID "gtkui_1"
 #endif
+#else
+typedef void GtkWidget;
+#endif
 
 #define DDB_GTKUI_API_VERSION_MAJOR 2
 #define DDB_GTKUI_API_VERSION_MINOR 1
@@ -209,6 +213,14 @@
 
     // get_default_cover_pixbuf returns the default cover art image
     GdkPixbuf *(*cover_get_default_pixbuf) (void);
+
+    // Status icon plugin support functions
+    void (*mainwin_toggle_visible) (void);
+    void (*show_traymenu) (void);
+
+    // Tell GTKUI that the standard status icon must be hidden, because another
+    // plugin wants to make it in a different way
+    void (*override_builtin_statusicon) (int override_);
 } ddb_gtkui_t;
 
 #endif
diff -Naur a/plugins/statusnotifier/COPYING b/plugins/statusnotifier/COPYING
--- a/plugins/statusnotifier/COPYING	1970-01-01 00:00:00.000000000 +0000
+++ b/plugins/statusnotifier/COPYING	2015-10-13 04:33:19.775520860 +0000
@@ -0,0 +1,21 @@
+KDE StatusNotifier plugin for DeaDBeeF
+Copyright (C) 2015 Giulio Bernardi
+
+This software is provided 'as-is', without any express or implied
+warranty.  In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must not
+ claim that you wrote the original software. If you use this software
+ in a product, an acknowledgment in the product documentation would be
+ appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and must not be
+ misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source distribution.
+
diff -Naur a/plugins/statusnotifier/Makefile.am b/plugins/statusnotifier/Makefile.am
--- a/plugins/statusnotifier/Makefile.am	1970-01-01 00:00:00.000000000 +0000
+++ b/plugins/statusnotifier/Makefile.am	2015-10-13 04:33:19.775520860 +0000
@@ -0,0 +1,12 @@
+if HAVE_STATUSNOTIFIER
+pkglib_LTLIBRARIES = statusnotifier.la
+
+AM_CFLAGS = $(CFLAGS) -std=c99 -fPIC
+
+statusnotifier_la_SOURCES = statusnotifier.c statusnotifier.h ddb_statusnotifier.c ddb_statusnotifier.h
+statusnotifier_la_LDFLAGS = -module -avoid-version
+statusnotifier_la_CFLAGS = -std=c99 $(STATUSNOTIFIER_DEPS_CFLAGS)
+statusnotifier_la_LIBADD = $(STATUSNOTIFIER_DEPS_LIBS)
+
+endif
+
diff -Naur a/plugins/statusnotifier/ddb_statusnotifier.c b/plugins/statusnotifier/ddb_statusnotifier.c
--- a/plugins/statusnotifier/ddb_statusnotifier.c	1970-01-01 00:00:00.000000000 +0000
+++ b/plugins/statusnotifier/ddb_statusnotifier.c	2015-10-13 04:33:19.775520860 +0000
@@ -0,0 +1,236 @@
+/*
+    KDE StatusNotifier plugin for DeaDBeeF
+    Copyright (C) 2015 Giulio Bernardi
+
+    This software is provided 'as-is', without any express or implied
+    warranty.  In no event will the authors be held liable for any damages
+    arising from the use of this software.
+
+    Permission is granted to anyone to use this software for any purpose,
+    including commercial applications, and to alter it and redistribute it
+    freely, subject to the following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifdef HAVE_CONFIG_H
+#include "../../config.h"
+#endif
+#include <string.h>
+#include <stdlib.h>
+#include "../../deadbeef.h"
+#include <glib.h>
+#include <gdk-pixbuf/gdk-pixbuf.h>
+#include "../gtkui/gtkui_api.h"
+#include "ddb_statusnotifier.h"
+#include "statusnotifier.h"
+
+//#define trace(...) { fprintf (stderr, __VA_ARGS__); }
+#define trace(...)
+
+DB_functions_t *deadbeef;
+static DB_statusnotifier_plugin_t plugin;
+static ddb_gtkui_t *gtkui_plugin;
+
+static StatusNotifierItem *notifier;
+static int sn_plugin_enabled = 1;
+
+static int
+sn_plugin_stop (void) {
+    trace ("DDB_SN: plugin stop\n");
+    if (notifier) {
+        sn_destroy (notifier);
+    }
+    notifier = NULL;
+    sn_finalize();
+    return 0;
+}
+
+static void
+notifier_create_status_icon_from_icon_name (const char * icon_name);
+
+static void
+sn_plugin_setup (void) {
+    if (!gtkui_plugin) {
+        gtkui_plugin = (ddb_gtkui_t *)deadbeef->plug_get_for_id ("gtkui_1");
+        if (!gtkui_plugin) {
+            gtkui_plugin = (ddb_gtkui_t *)deadbeef->plug_get_for_id ("gtkui3_1");
+        }
+    }
+    if (!gtkui_plugin) {
+        trace ("DDB_SN: failed to connect to gtkui plugin\n");
+        return;
+    }
+    sn_plugin_enabled  = deadbeef->conf_get_int ("statusnotifier.enable", 1);
+    if (!sn_plugin_enabled) {
+        if (notifier) {
+            sn_destroy (notifier);
+            notifier = NULL;
+        }
+        gtkui_plugin->override_builtin_statusicon (0);
+        return;
+    }
+    gtkui_plugin->override_builtin_statusicon (1);
+    trace ("DDB_SN: sn_plugin_setup ()\n");
+
+    if (!notifier) {
+        notifier_create_status_icon_from_icon_name ("deadbeef");
+    }
+}
+
+static void
+on_notifier_activate (StatusNotifierItem *sn, int x, int y) {
+    gtkui_plugin->mainwin_toggle_visible ();
+}
+
+static void
+on_notifier_secondary_activate (StatusNotifierItem *sn, int x, int y) {
+    deadbeef->sendmessage (DB_EV_TOGGLE_PAUSE, 0, 0, 0);
+}
+
+static void
+on_notifier_reg_failed (StatusNotifierItem *sn, char *iconstr) {
+    fprintf (stderr,"Cannot create status notifier, falling back to GtkStatusIcon\n");
+    gtkui_plugin->override_builtin_statusicon (0);
+}
+
+static void
+on_notifier_popup_menu (StatusNotifierItem *sn, int x, int y) {
+    gtkui_plugin->show_traymenu ();
+}
+
+static void
+on_notifier_scroll (StatusNotifierItem *sn, int delta, SN_SCROLLDIR orientation) {
+    float vol = deadbeef->volume_get_db ();
+    int sens = deadbeef->conf_get_int ("gtkui.tray_volume_sensitivity", 1);
+    if (orientation == Horizontal) {
+        delta = -delta;
+    }
+    if (delta < 0) {
+        vol -= sens;
+    }
+    else if (delta > 0) {
+        vol += sens;
+    }
+
+    if (vol > 0) {
+        vol = 0;
+    }
+    else if (vol < deadbeef->volume_get_min_db ()) {
+        vol = deadbeef->volume_get_min_db ();
+    }
+    deadbeef->volume_set_db (vol);
+}
+
+static void
+notifier_initialize_status_icon (const char * iconstr) {
+    trace ("DDB_SN: connecting button tray signals\n");
+    sn_hook_on_registration_error (notifier,
+            (cb_registration_error)on_notifier_reg_failed,
+            g_strdup (iconstr),g_free);
+    sn_hook_on_context_menu (notifier,on_notifier_popup_menu);
+    sn_hook_on_activate (notifier,on_notifier_activate);
+    sn_hook_on_secondary_activate (notifier,on_notifier_secondary_activate);
+    sn_hook_on_scroll (notifier,on_notifier_scroll);
+    sn_register_item (notifier);
+}
+
+static void
+notifier_create_status_icon_from_file (const char * iconfile) {
+    GError *err = NULL;
+    GdkPixbuf *pixbuf = gdk_pixbuf_new_from_file (iconfile, &err);
+    notifier = sn_create_with_icondata ("deadbeef-notifier",ApplicationStatus,pixbuf);
+    sn_set_tooltip_icondata (notifier,pixbuf);
+    notifier_initialize_status_icon (iconfile);
+}
+
+static void
+notifier_create_status_icon_from_icon_name (const char * icon_name) {
+    notifier = sn_create_with_iconname ("deadbeef-notifier", ApplicationStatus, icon_name);
+    sn_set_tooltip_iconname (notifier,icon_name);
+    notifier_initialize_status_icon (icon_name);
+}
+
+static void
+notifier_set_status_icon_tooltip (const char *title, const char *text) {
+    sn_set_tooltip_title (notifier, title);
+    sn_set_tooltip_text (notifier, text);
+}
+
+static gboolean
+notifier_is_status_icon_allocated (void) {
+    return notifier != NULL ? TRUE : FALSE;
+}
+
+static int
+sn_plugin_message (uint32_t id, uintptr_t ctx, uint32_t p1, uint32_t p2) {
+    int enabled;
+    switch (id) {
+    case DB_EV_CONFIGCHANGED:
+        enabled = deadbeef->conf_get_int ("statusnotifier.enable", 1);
+        if (sn_plugin_enabled != enabled) {
+            sn_plugin_enabled = enabled;
+            sn_plugin_setup ();
+        }
+        break;
+    case DB_EV_PLUGINSLOADED:
+        sn_plugin_setup ();
+        break;
+    }
+    return 0;
+}
+
+static const char settings_dlg[] =
+    "property \"Enable\" checkbox statusnotifier.enable 1;\n"
+;
+
+static DB_statusnotifier_plugin_t plugin = {
+    .plugin.plugin.api_vmajor = 1,
+    .plugin.plugin.api_vminor = 8,
+    .plugin.plugin.version_major = 0,
+    .plugin.plugin.version_minor = 1,
+    .plugin.plugin.type = DB_PLUGIN_MISC,
+    .plugin.plugin.id = "statusnotifier",
+    .plugin.plugin.name = "KDE Status Notifier",
+    .plugin.plugin.descr = "System tray icon support for KDE 5",
+    .plugin.plugin.copyright =
+        "KDE StatusNotifier plugin for DeaDBeeF\n"
+        "Copyright (C) 2015 Giulio Bernardi\n"
+        "\n"
+        "This software is provided 'as-is', without any express or implied\n"
+        "warranty.  In no event will the authors be held liable for any damages\n"
+        "arising from the use of this software.\n"
+        "\n"
+        "Permission is granted to anyone to use this software for any purpose,\n"
+        "including commercial applications, and to alter it and redistribute it\n"
+        "freely, subject to the following restrictions:\n"
+        "\n"
+        "1. The origin of this software must not be misrepresented; you must not\n"
+        " claim that you wrote the original software. If you use this software\n"
+        " in a product, an acknowledgment in the product documentation would be\n"
+        " appreciated but is not required.\n"
+        "\n"
+        "2. Altered source versions must be plainly marked as such, and must not be\n"
+        " misrepresented as being the original software.\n"
+        "\n"
+        "3. This notice may not be removed or altered from any source distribution.\n"
+    ,
+    .plugin.plugin.website = "http://deadbeef.sf.net",
+    .plugin.plugin.stop = sn_plugin_stop,
+    .plugin.plugin.configdialog = settings_dlg,
+    .plugin.plugin.message = sn_plugin_message,
+};
+
+DB_plugin_t *
+statusnotifier_load (DB_functions_t *api) {
+    deadbeef = api;
+    return DB_PLUGIN (&plugin);
+}
diff -Naur a/plugins/statusnotifier/ddb_statusnotifier.h b/plugins/statusnotifier/ddb_statusnotifier.h
--- a/plugins/statusnotifier/ddb_statusnotifier.h	1970-01-01 00:00:00.000000000 +0000
+++ b/plugins/statusnotifier/ddb_statusnotifier.h	2015-10-13 04:33:19.775520860 +0000
@@ -0,0 +1,34 @@
+/*
+    KDE StatusNotifier plugin for DeaDBeeF
+    Copyright (C) 2015 Giulio Bernardi
+
+    This software is provided 'as-is', without any express or implied
+    warranty.  In no event will the authors be held liable for any damages
+    arising from the use of this software.
+
+    Permission is granted to anyone to use this software for any purpose,
+    including commercial applications, and to alter it and redistribute it
+    freely, subject to the following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef _DDB_STATUSNOTIFIER_H
+#define _DDB_STATUSNOTIFIER_H
+
+#include "../../deadbeef.h"
+#include "../gtkui/gtkui_api.h"
+
+typedef struct {
+    DB_misc_t plugin;
+} DB_statusnotifier_plugin_t;
+
+#endif /*_DDB_STATUSNOTIFIER_H*/
+
diff -Naur a/plugins/statusnotifier/statusnotifier.c b/plugins/statusnotifier/statusnotifier.c
--- a/plugins/statusnotifier/statusnotifier.c	1970-01-01 00:00:00.000000000 +0000
+++ b/plugins/statusnotifier/statusnotifier.c	2015-10-13 04:33:19.775520860 +0000
@@ -0,0 +1,692 @@
+/*
+    StatusNotifierItem support library for GTK
+    Copyright (C) 2015 Giulio Bernardi
+
+    This software is provided 'as-is', without any express or implied
+    warranty.  In no event will the authors be held liable for any damages
+    arising from the use of this software.
+
+    Permission is granted to anyone to use this software for any purpose,
+    including commercial applications, and to alter it and redistribute it
+    freely, subject to the following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include "statusnotifier.h"
+
+//#define trace(...) { fprintf(stderr, __VA_ARGS__); }
+#define trace(fmt,...)
+
+//Globals
+
+static GDBusNodeInfo *introspection_data = NULL;
+static int next_indicator_id = 1;
+
+static const gchar introspection_xml[] =
+        "<node>"
+        "  <interface name='org.kde.StatusNotifierItem'>"
+        "    <property type='s' name='Category' access='read'/>"
+        "    <property type='s' name='Id' access='read'/>"
+        "    <property type='s' name='Title' access='read'/>"
+        "    <property type='s' name='Status' access='read'/>"
+        "    <property type='u' name='WindowId' access='read'/>"
+        "    <property type='s' name='IconName' access='read'/>"
+        "    <property type='a(iiay)' name='IconPixmap' access='read'/>"
+        "    <property type='s' name='OverlayIconName' access='read'/>"
+        "    <property type='a(iiay)' name='OverlayIconPixmap' access='read'/>"
+        "    <property type='s' name='AttentionIconName' access='read'/>"
+        "    <property type='a(iiay)' name='AttentionIconPixmap' access='read'/>"
+        "    <property type='s' name='AttentionMovieName' access='read'/>"
+        "    <property type='(sa(iiay)ss)' name='ToolTip' access='read'/>"
+        "    <method name='ContextMenu'>"
+        "      <annotation name='org.kde.DBus.Method.NoReply' value='true'/>"
+        "      <arg type='i' name='x' direction='in'/>"
+        "      <arg type='i' name='y' direction='in'/>"
+        "    </method>"
+        "    <method name='Activate'>"
+        "      <annotation name='org.kde.DBus.Method.NoReply' value='true'/>"
+        "      <arg type='i' name='x' direction='in'/>"
+        "      <arg type='i' name='y' direction='in'/>"
+        "    </method>"
+        "    <method name='SecondaryActivate'>"
+        "      <annotation name='org.kde.DBus.Method.NoReply' value='true'/>"
+        "      <arg type='i' name='x' direction='in'/>"
+        "      <arg type='i' name='y' direction='in'/>"
+        "    </method>"
+        "    <method name='Scroll'>"
+        "      <annotation name='org.kde.DBus.Method.NoReply' value='true'/>"
+        "      <arg type='i' name='delta' direction='in'/>"
+        "      <arg type='s' name='orientation' direction='in'/>"
+        "    </method>"
+        "    <signal name='NewTitle'/>"
+        "    <signal name='NewIcon'/>"
+        "    <signal name='NewAttentionIcon'/>"
+        "    <signal name='NewOverlayIcon'/>"
+        "    <signal name='NewToolTip'/>"
+        "    <signal name='NewStatus'/>"
+        "  </interface>"
+        "</node>";
+
+//data structures
+
+typedef struct _IconData {
+    int w, h;
+    guchar *pixdata;
+    guint len;
+} IconData;
+
+typedef struct _ToolTipData {
+    gchar *iconname;
+    IconData *icondata;
+    gchar *title;
+    gchar *text;
+} ToolTipData;
+
+typedef struct _StatusNotifierItem {
+    GDBusConnection *connection;
+    gchar *service_name;
+    guint owner_id;
+    guint registration_id;
+    guint watcher_id;
+
+    gchar *category;
+    gchar *id;
+    gchar *title;
+    gchar *status;
+    unsigned int windowid;
+    gchar *iconname;
+    IconData *iconpixmap;
+    gchar *overlayiconname;
+    IconData *overlayiconpixmap;
+    gchar *attentioniconname;
+    IconData *attentioniconpixmap;
+    gchar *attentionmoviename;
+    ToolTipData tooltip;
+
+    //events
+    void (*on_context_menu)(StatusNotifierItem *this, int x, int y);
+    void (*on_activate)(StatusNotifierItem *this, int x, int y);
+    void (*on_secondary_activate)(StatusNotifierItem *this, int x, int y);
+    void (*on_scroll)(StatusNotifierItem *this, int delta,
+            SN_SCROLLDIR orientation);
+    void (*on_registration_error)(StatusNotifierItem *this, void *data);
+
+    void *regerr_data;
+    void (*destroy_regerr_data)(void *data);
+} StatusNotifierItem;
+
+static char* SN_CATEGORY_STR[] = { "ApplicationStatus", "Communications",
+        "SystemServices", "Hardware", NULL };
+
+static char* SN_STATUS_STR[] = { "Passive", "Active", "NeedsAttention", NULL };
+
+#define nn(X) ((X)==NULL) ? "" : (X)
+
+//private methods
+
+static void sn_emit_signal(StatusNotifierItem *this, char *name) {
+    if (this->connection)
+        g_dbus_connection_emit_signal(this->connection,
+        NULL, "/StatusNotifierItem", "org.kde.StatusNotifierItem", name,
+        NULL,
+        NULL);
+}
+
+static void sn_setstr(gchar **var, const gchar *value) {
+    if (*var)
+        g_free(*var);
+    *var = g_strdup(value);
+}
+
+static void sn_rgba_to_argb(IconData *id) {
+    guchar *data = (id->pixdata);
+    guchar *end = (id->pixdata + id->len);
+    while (data < end) {
+        guchar alpha = data[3];
+        data[3] = data[2]; //B
+        data[2] = data[1]; //G
+        data[1] = data[0]; //R
+        data[0] = alpha;   //A
+        data += 4;
+    }
+}
+
+static void sn_get_pixel_rowstride(IconData *id, GdkPixbuf* pixbuf,
+        int rowstride) {
+    int newsize = id->w * id->h * 4;
+    guchar *buf = g_malloc(newsize);
+    guchar *src = gdk_pixbuf_get_pixels(pixbuf);
+    guchar *end = src + id->len;
+    while (src < end) {
+        memmove(buf, src, id->w);
+        buf += id->w;
+        src += rowstride;
+    }
+    id->len = newsize;
+    id->pixdata = buf;
+}
+
+static void sn_seticondata(IconData **data, GdkPixbuf* pixbuf) {
+    if (*data) {
+        if ((*data)->pixdata)
+            g_free((*data)->pixdata);
+        g_free(*data);
+        *data = NULL;
+    }
+    if (!pixbuf)
+        return;
+
+    g_assert(gdk_pixbuf_get_colorspace(pixbuf) == GDK_COLORSPACE_RGB);
+    g_assert(gdk_pixbuf_get_bits_per_sample(pixbuf) == 8);
+    g_assert(gdk_pixbuf_get_has_alpha(pixbuf));
+    g_assert(gdk_pixbuf_get_n_channels(pixbuf) == 4);
+
+    int rowstride = gdk_pixbuf_get_rowstride(pixbuf);
+
+    IconData *id = g_malloc(sizeof(IconData));
+    id->w = gdk_pixbuf_get_width(pixbuf);
+    id->h = gdk_pixbuf_get_height(pixbuf);
+    id->len = rowstride*id->h;
+    if (rowstride > (id->w * 4))
+        sn_get_pixel_rowstride(id, pixbuf, rowstride);
+    else
+        id->pixdata = g_memdup(gdk_pixbuf_get_pixels(pixbuf), id->len);
+    sn_rgba_to_argb(id);
+
+    *data = id;
+}
+
+//public methods
+
+void sn_set_title(StatusNotifierItem *this, const gchar *title) {
+    sn_setstr(&this->title, title);
+    sn_emit_signal(this, "NewTitle");
+}
+
+void sn_set_status(StatusNotifierItem *this, SN_STATUS status) {
+    sn_setstr(&this->status, SN_STATUS_STR[status]);
+    sn_emit_signal(this, "NewStatus");
+}
+
+void sn_set_icon_name(StatusNotifierItem *this, const gchar *iconname) {
+    sn_setstr(&this->iconname, iconname);
+    sn_emit_signal(this, "NewIcon");
+}
+
+void sn_set_icon_pixmap(StatusNotifierItem *this, GdkPixbuf* pixbuf) {
+    sn_seticondata(&this->iconpixmap, pixbuf);
+    sn_emit_signal(this, "NewIcon");
+}
+
+void sn_set_attention_icon_name(StatusNotifierItem *this, const gchar *iconname) {
+    sn_setstr(&this->attentioniconname, iconname);
+    sn_emit_signal(this, "NewAttentionIcon");
+}
+
+void sn_set_attention_icon_pixmap(StatusNotifierItem *this, GdkPixbuf* pixbuf) {
+    sn_seticondata(&this->attentioniconpixmap, pixbuf);
+    sn_emit_signal(this, "NewAttentionIcon");
+}
+
+void sn_set_overlay_icon_name(StatusNotifierItem *this, const gchar *iconname) {
+    sn_setstr(&this->overlayiconname, iconname);
+    sn_emit_signal(this, "NewOverlayIcon");
+}
+
+void sn_set_overlay_icon_pixmap(StatusNotifierItem *this, GdkPixbuf* pixbuf) {
+    sn_seticondata(&this->overlayiconpixmap, pixbuf);
+    sn_emit_signal(this, "NewOverlayIcon");
+}
+
+void sn_set_attention_movie_name(StatusNotifierItem *this,
+        const gchar *iconname) {
+    sn_setstr(&this->attentionmoviename, iconname);
+    sn_emit_signal(this, "NewAttentionIcon");
+}
+
+void sn_set_tooltip(StatusNotifierItem *this, const gchar *iconname,
+        GdkPixbuf *pixbuf, const gchar *title, const gchar *text) {
+    sn_setstr(&this->tooltip.iconname, iconname);
+    sn_seticondata(&this->tooltip.icondata, pixbuf);
+    sn_setstr(&this->tooltip.title, title);
+    sn_setstr(&this->tooltip.text, text);
+    sn_emit_signal(this, "NewToolTip");
+}
+
+void sn_set_tooltip_iconname(StatusNotifierItem *this, const gchar *iconname) {
+    sn_setstr(&this->tooltip.iconname, iconname);
+    sn_emit_signal(this, "NewToolTip");
+}
+
+void sn_set_tooltip_icondata(StatusNotifierItem *this, GdkPixbuf *pixbuf) {
+    sn_seticondata(&this->tooltip.icondata, pixbuf);
+    sn_emit_signal(this, "NewToolTip");
+}
+
+void sn_set_tooltip_title(StatusNotifierItem *this, const gchar *title) {
+    sn_setstr(&this->tooltip.title, title);
+    sn_emit_signal(this, "NewToolTip");
+}
+
+void sn_set_tooltip_text(StatusNotifierItem *this, const gchar *text) {
+    sn_setstr(&this->tooltip.text, text);
+    sn_emit_signal(this, "NewToolTip");
+}
+
+const gchar* sn_get_id(StatusNotifierItem *this) {
+    return this->id;
+}
+
+const gchar* sn_get_title(StatusNotifierItem *this) {
+    return this->title;
+}
+
+const gchar* sn_get_icon_name(StatusNotifierItem *this) {
+    return this->iconname;
+}
+
+const gboolean sn_has_icon_pixmap(StatusNotifierItem *this) {
+    return this->iconpixmap != NULL;
+}
+
+const gchar* sn_get_attention_icon_name(StatusNotifierItem *this) {
+    return this->attentioniconname;
+}
+
+const gboolean sn_has_attention_icon_pixmap(StatusNotifierItem *this) {
+    return this->attentioniconpixmap != NULL;
+}
+
+const gchar* sn_get_overlay_icon_name(StatusNotifierItem *this) {
+    return this->overlayiconname;
+}
+
+const gboolean sn_has_overlay_icon_pixmap(StatusNotifierItem *this) {
+    return this->overlayiconpixmap != NULL;
+}
+
+const gchar* sn_get_attention_movie_name(StatusNotifierItem *this) {
+    return this->attentionmoviename;
+}
+
+const gchar* sn_get_tooltip_iconname(StatusNotifierItem *this) {
+    return this->tooltip.iconname;
+}
+
+const gboolean sn_has_tooltip_icondata(StatusNotifierItem *this) {
+    return this->tooltip.icondata != NULL;
+}
+
+const gchar* sn_get_tooltip_title(StatusNotifierItem *this) {
+    return this->tooltip.title;
+}
+
+const gchar* sn_get_tooltip_text(StatusNotifierItem *this) {
+    return this->tooltip.text;
+}
+
+//forward
+static void on_bus_acquired(GDBusConnection *connection, const gchar *name,
+        gpointer user_data);
+static void
+on_name_acquired(GDBusConnection *connection, const gchar *name,
+        gpointer user_data);
+static void
+on_name_lost(GDBusConnection *connection, const gchar *name, gpointer user_data);
+
+void sn_register_item(StatusNotifierItem *this) {
+    if (!introspection_data)
+        introspection_data = g_dbus_node_info_new_for_xml(introspection_xml,
+                NULL);
+    //if there is only 1 instance, refcount is 2: it is released only by explicit
+    //call to sn_finalize()
+    g_dbus_node_info_ref(introspection_data);
+
+    g_assert(introspection_data != NULL);
+
+    trace("StatusNotifier: calling g_bus_own_name()\n");
+
+    this->owner_id = g_bus_own_name(G_BUS_TYPE_SESSION, this->service_name,
+            G_BUS_NAME_OWNER_FLAGS_NONE, on_bus_acquired, on_name_acquired,
+            on_name_lost, this,
+            NULL);
+}
+
+void sn_unregister(StatusNotifierItem *this) {
+    if (this->watcher_id) {
+        g_bus_unwatch_name(this->watcher_id);
+        this->watcher_id = 0;
+    }
+    if (this->registration_id && this->connection) {
+        g_dbus_connection_unregister_object(this->connection,
+                this->registration_id);
+        this->registration_id = 0;
+    }
+    this->connection = NULL;
+    if (this->owner_id) {
+        g_bus_unown_name(this->owner_id);
+        this->owner_id = 0;
+        g_dbus_node_info_unref(introspection_data);
+    }
+}
+
+StatusNotifierItem *sn_create_with_iconname(const gchar *id,
+        SN_CATEGORY category, const gchar *iconname) {
+    trace("StatusNotifier: sn_create_with_iconname()\n");
+
+    StatusNotifierItem *this = malloc(sizeof(StatusNotifierItem));
+    memset(this, 0, sizeof(StatusNotifierItem));
+
+    this->service_name = g_strdup_printf("org.kde.StatusNotifierItem-%d-%d",
+            getpid(), next_indicator_id++);
+
+    this->category = g_strdup(SN_CATEGORY_STR[category]);
+    this->id = g_strdup(id);
+    this->iconname = g_strdup(iconname);
+    this->status = g_strdup("Passive");
+
+    return this;
+}
+
+StatusNotifierItem *sn_create_with_icondata(const gchar *id,
+        SN_CATEGORY category, GdkPixbuf *icondata) {
+    trace("StatusNotifier: sn_create_with_icondata()\n");
+
+    StatusNotifierItem *this = malloc(sizeof(StatusNotifierItem));
+    memset(this, 0, sizeof(StatusNotifierItem));
+
+    this->service_name = g_strdup_printf("org.kde.StatusNotifierItem-%d-%d",
+            getpid(), next_indicator_id++);
+
+    this->category = g_strdup(SN_CATEGORY_STR[category]);
+    this->id = g_strdup(id);
+    sn_seticondata(&this->iconpixmap, icondata);
+    this->status = g_strdup("Passive");
+
+    return this;
+}
+
+void sn_destroy(gpointer data) {
+    trace("StatusNotifier: sn_destroy()\n");
+
+    StatusNotifierItem *this = (StatusNotifierItem *) data;
+
+    sn_unregister(this);
+    sn_setstr(&this->service_name, NULL);
+
+    sn_setstr(&this->category, NULL);
+    sn_setstr(&this->id, NULL);
+    sn_setstr(&this->title, NULL);
+    sn_setstr(&this->status, NULL);
+    sn_setstr(&this->iconname, NULL);
+    sn_seticondata(&this->iconpixmap, NULL);
+    sn_setstr(&this->overlayiconname, NULL);
+    sn_seticondata(&this->overlayiconpixmap, NULL);
+    sn_setstr(&this->attentioniconname, NULL);
+    sn_seticondata(&this->attentioniconpixmap, NULL);
+    sn_setstr(&this->attentionmoviename, NULL);
+    sn_setstr(&this->tooltip.iconname, NULL);
+    sn_seticondata(&this->tooltip.icondata, NULL);
+    sn_setstr(&this->tooltip.title, NULL);
+    sn_setstr(&this->tooltip.text, NULL);
+}
+
+void sn_finalize() {
+    if (introspection_data)
+        g_dbus_node_info_unref(introspection_data);
+    introspection_data = NULL;
+}
+
+void sn_hook_on_context_menu(StatusNotifierItem *this, cb_context_menu cb) {
+    this->on_context_menu = cb;
+}
+
+void sn_hook_on_activate(StatusNotifierItem *this, cb_activate cb) {
+    this->on_activate = cb;
+}
+
+void sn_hook_on_secondary_activate(StatusNotifierItem *this,
+        cb_secondary_activate cb) {
+    this->on_secondary_activate = cb;
+}
+
+void sn_hook_on_scroll(StatusNotifierItem *this, cb_scroll cb) {
+    this->on_scroll = cb;
+}
+
+void sn_hook_on_registration_error(StatusNotifierItem *this,
+        cb_registration_error cb, void *data,
+        cb_destroy_regerr_data userdata_del_cb) {
+    this->on_registration_error = cb;
+    this->regerr_data = data;
+    this->destroy_regerr_data = userdata_del_cb;
+}
+
+//callbacks
+
+static void sn_context_menu(StatusNotifierItem *this, int x, int y) {
+    trace("StatusNotifier: sn_context_menu(%d,%d)\n",x,y);
+    if (this->on_context_menu)
+        this->on_context_menu(this, x, y);
+}
+
+static void sn_activate(StatusNotifierItem *this, int x, int y) {
+    trace("StatusNotifier: sn_activate(%d,%d)\n",x,y);
+    if (this->on_activate)
+        this->on_activate(this, x, y);
+}
+
+static void sn_secondary_activate(StatusNotifierItem *this, int x, int y) {
+    trace("StatusNotifier: sn_secondary_activate(%d,%d)\n",x,y);
+    if (this->on_secondary_activate)
+        this->on_secondary_activate(this, x, y);
+}
+
+static void sn_scroll(StatusNotifierItem *this, int delta,
+        const gchar *orientation) {
+    trace("StatusNotifier: sn_scroll(%d,%s)\n",delta,orientation);
+    if (this->on_scroll) {
+        SN_SCROLLDIR dir =
+                g_ascii_strncasecmp(orientation, "vertical", 9) == 0 ?
+                        Vertical : Horizontal;
+        this->on_scroll(this, delta, dir);
+    }
+}
+
+static void sn_finalize_regerr_data(StatusNotifierItem *this) {
+    if (this->destroy_regerr_data)
+        this->destroy_regerr_data(this->regerr_data);
+    this->regerr_data = NULL;
+    this->destroy_regerr_data = NULL;
+}
+
+static void sn_raise_registration_error(StatusNotifierItem *this) {
+    if (this->on_registration_error)
+        this->on_registration_error(this, this->regerr_data);
+    sn_finalize_regerr_data(this);
+}
+
+static void handle_method_call(GDBusConnection *connection, const gchar *sender,
+        const gchar *object_path, const gchar *interface_name,
+        const gchar *method_name, GVariant *parameters,
+        GDBusMethodInvocation *invocation, gpointer user_data) {
+    trace("StatusNotifier: handle_method_call()\n");
+    StatusNotifierItem *instance = (StatusNotifierItem *) user_data;
+    if (g_strcmp0(method_name, "ContextMenu") == 0) {
+        gint x, y;
+        g_variant_get(parameters, "(ii)", &x, &y);
+        sn_context_menu(instance, x, y);
+    } else if (g_strcmp0(method_name, "Activate") == 0) {
+        gint x, y;
+        g_variant_get(parameters, "(ii)", &x, &y);
+        sn_activate(instance, x, y);
+    } else if (g_strcmp0(method_name, "SecondaryActivate") == 0) {
+        gint x, y;
+        g_variant_get(parameters, "(ii)", &x, &y);
+        sn_secondary_activate(instance, x, y);
+    } else if (g_strcmp0(method_name, "Scroll") == 0) {
+        gint delta;
+        const gchar *orientation;
+        g_variant_get(parameters, "(i&s)", &delta, &orientation);
+        sn_scroll(instance, delta, orientation);
+    } else {
+        fprintf(stderr, "StatusNotifier: Unknown dbus method '%s', ignoring\n",
+                method_name);
+    }
+}
+
+static GVariant* icondata_to_variant(IconData* id) {
+    GVariant *ret = NULL;
+
+    GVariantBuilder *bld;
+    bld = g_variant_builder_new(G_VARIANT_TYPE("a(iiay)"));
+    if (id) {
+        GVariant *pixdata = g_variant_new_from_data(G_VARIANT_TYPE("ay"),
+                id->pixdata, id->len, TRUE, NULL, NULL);
+        g_variant_builder_add(bld, "(ii@ay)", id->w, id->h, pixdata);
+    }
+    ret = g_variant_new("a(iiay)", bld);
+    g_variant_builder_unref(bld);
+
+    return ret;
+}
+
+static GVariant *tooltip_to_variant(ToolTipData *tt) {
+    return g_variant_new("(s@a(iiay)ss)", nn(tt->iconname),
+            icondata_to_variant(tt->icondata), nn(tt->title), nn(tt->text));
+}
+
+static GVariant *
+handle_get_property(GDBusConnection *connection, const gchar *sender,
+        const gchar *object_path, const gchar *interface_name,
+        const gchar *property_name, GError **error, gpointer user_data) {
+    trace("StatusNotifier: handle_get_property()\n");
+    GVariant *ret;
+
+    StatusNotifierItem *instance = (StatusNotifierItem *) user_data;
+
+    ret = NULL;
+    if (g_strcmp0(property_name, "Category") == 0)
+        ret = g_variant_new_string(nn(instance->category));
+    else if (g_strcmp0(property_name, "Id") == 0)
+        ret = g_variant_new_string(nn(instance->id));
+    else if (g_strcmp0(property_name, "Title") == 0)
+        ret = g_variant_new_string(nn(instance->title));
+    else if (g_strcmp0(property_name, "Status") == 0)
+        ret = g_variant_new_string(nn(instance->status));
+    else if (g_strcmp0(property_name, "WindowId") == 0)
+        ret = g_variant_new_uint32(instance->windowid);
+    else if (g_strcmp0(property_name, "IconName") == 0)
+        ret = g_variant_new_string(nn(instance->iconname));
+    else if (g_strcmp0(property_name, "IconPixmap") == 0)
+        ret = icondata_to_variant(instance->iconpixmap);
+    else if (g_strcmp0(property_name, "OverlayIconName") == 0)
+        ret = g_variant_new_string(nn(instance->overlayiconname));
+    else if (g_strcmp0(property_name, "OverlayIconPixmap") == 0)
+        ret = icondata_to_variant(instance->overlayiconpixmap);
+    else if (g_strcmp0(property_name, "AttentionIconName") == 0)
+        ret = g_variant_new_string(nn(instance->attentioniconname));
+    else if (g_strcmp0(property_name, "AttentionIconPixmap") == 0)
+        ret = icondata_to_variant(instance->attentioniconpixmap);
+    else if (g_strcmp0(property_name, "AttentionMovieName") == 0)
+        ret = g_variant_new_string(nn(instance->attentionmoviename));
+    else if (g_strcmp0(property_name, "ToolTip") == 0)
+        ret = tooltip_to_variant(&(instance->tooltip));
+    else {
+        fprintf(stderr,
+                "StatusNotifier: Unknown dbus property '%s', returning NULL\n",
+                property_name);
+    }
+
+    return ret;
+}
+
+static gboolean handle_set_property(GDBusConnection *connection,
+        const gchar *sender, const gchar *object_path,
+        const gchar *interface_name, const gchar *property_name,
+        GVariant *value, GError **error, gpointer user_data) {
+    g_set_error(error, G_IO_ERROR, G_IO_ERROR_READ_ONLY,
+            "Properties are read only");
+
+    return FALSE;
+}
+
+static void on_name_appeared(GDBusConnection *connection, const gchar *name,
+        const gchar *name_owner, gpointer user_data) {
+    trace("StatusNotifier: on_name_appeared(), '%s' is owned by '%s'\n",name,name_owner);
+    StatusNotifierItem *item = (StatusNotifierItem *) user_data;
+    GError *error = NULL;
+    g_dbus_connection_call_sync(connection, name_owner,
+            "/StatusNotifierWatcher", "org.kde.StatusNotifierWatcher",
+            "RegisterStatusNotifierItem",
+            g_variant_new("(s)", item->service_name),
+            NULL, G_DBUS_CALL_FLAGS_NONE, -1,
+            NULL, &error);
+    if (error != NULL)
+        sn_raise_registration_error(item);
+    else {
+        item->connection = connection;
+        sn_finalize_regerr_data(item);
+    }
+}
+
+static void on_name_vanished(GDBusConnection *connection, const gchar *name,
+        gpointer user_data) {
+    trace("StatusNotifier: No owner for '%s', notifier watcher not running?\n",name);
+    StatusNotifierItem *item = (StatusNotifierItem *) user_data;
+    if (!item->connection)
+        sn_raise_registration_error(item);
+    //else the watcher disappeared but it was there before: let's wait for it
+    //to come back later.
+}
+
+static const GDBusInterfaceVTable interface_vtable = { handle_method_call,
+        handle_get_property, handle_set_property };
+
+static void on_bus_acquired(GDBusConnection *connection, const gchar *name,
+        gpointer user_data) {
+    trace("StatusNotifier: on_bus_acquired(), registering object\n");
+
+    StatusNotifierItem *item = (StatusNotifierItem *) user_data;
+
+    item->registration_id = g_dbus_connection_register_object(connection,
+            "/StatusNotifierItem", introspection_data->interfaces[0],
+            &interface_vtable, item,
+            NULL,
+            NULL);
+    if (!item->registration_id) {
+        sn_raise_registration_error(item);
+        return;
+    } trace("StatusNotifier: object registered to dbus\n");
+
+    trace("StatusNotifier: registering to StatusNotifierWatcher\n");
+    item->watcher_id = g_bus_watch_name(G_BUS_TYPE_SESSION,
+            "org.kde.StatusNotifierWatcher", G_BUS_NAME_WATCHER_FLAGS_NONE,
+            on_name_appeared, on_name_vanished, item,
+            NULL);
+}
+
+static void on_name_acquired(GDBusConnection *connection, const gchar *name,
+        gpointer user_data) {
+    trace("StatusNotifier: on_name_acquired(), ignoring\n");
+}
+
+static void on_name_lost(GDBusConnection *connection, const gchar *name,
+        gpointer user_data) {
+    trace("StatusNotifier: Connection lost!\n");
+    StatusNotifierItem *item = (StatusNotifierItem *) user_data;
+    if (!item->connection)
+        sn_raise_registration_error(item);
+}
diff -Naur a/plugins/statusnotifier/statusnotifier.h b/plugins/statusnotifier/statusnotifier.h
--- a/plugins/statusnotifier/statusnotifier.h	1970-01-01 00:00:00.000000000 +0000
+++ b/plugins/statusnotifier/statusnotifier.h	2015-10-13 04:33:19.775520860 +0000
@@ -0,0 +1,106 @@
+/*
+    StatusNotifierItem support library for GTK
+    Copyright (C) 2015 Giulio Bernardi
+
+    This software is provided 'as-is', without any express or implied
+    warranty.  In no event will the authors be held liable for any damages
+    arising from the use of this software.
+
+    Permission is granted to anyone to use this software for any purpose,
+    including commercial applications, and to alter it and redistribute it
+    freely, subject to the following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef STATUSNOTIFIER_H
+#define STATUSNOTIFIER_H
+
+#include <glib.h>
+#include <gdk-pixbuf/gdk-pixbuf.h>
+
+typedef enum {
+	ApplicationStatus,
+	Communications,
+	SystemServices,
+	Hardware
+} SN_CATEGORY;
+
+typedef enum {
+	Passive,
+	Active,
+	NeedsAttention
+} SN_STATUS;
+
+typedef enum {
+	Vertical,
+	Horizontal
+} SN_SCROLLDIR;
+
+typedef struct _StatusNotifierItem StatusNotifierItem;
+
+typedef void (*cb_context_menu) (StatusNotifierItem *this, int x, int y);
+typedef void (*cb_activate) (StatusNotifierItem *this, int x, int y);
+typedef void (*cb_secondary_activate) (StatusNotifierItem *this, int x, int y);
+typedef void (*cb_scroll) (StatusNotifierItem *this, int delta, SN_SCROLLDIR orientation);
+typedef void (*cb_registration_error) (StatusNotifierItem *this, void *data);
+typedef void (*cb_destroy_regerr_data) (void *data);
+
+
+StatusNotifierItem *sn_create_with_iconname(const gchar *id, SN_CATEGORY category, const gchar *iconname);
+StatusNotifierItem *sn_create_with_icondata(const gchar *id, SN_CATEGORY category, GdkPixbuf *icondata);
+void sn_destroy (gpointer data);
+void sn_finalize();
+
+void sn_set_title(StatusNotifierItem *this, const gchar *title);
+void sn_set_status(StatusNotifierItem *this, SN_STATUS status);
+void sn_set_icon_name(StatusNotifierItem *this, const gchar *iconname);
+void sn_set_icon_pixmap(StatusNotifierItem *this, GdkPixbuf* pixbuf);
+void sn_set_attention_icon_name(StatusNotifierItem *this, const gchar *iconname);
+void sn_set_attention_icon_pixmap(StatusNotifierItem *this, GdkPixbuf* pixbuf);
+void sn_set_overlay_icon_name(StatusNotifierItem *this, const gchar *iconname);
+void sn_set_overlay_icon_pixmap(StatusNotifierItem *this, GdkPixbuf* pixbuf);
+void sn_set_attention_movie_name(StatusNotifierItem *this, const gchar *iconname);
+void sn_set_tooltip(StatusNotifierItem *this,
+		const gchar *iconname,
+		GdkPixbuf *pixbuf,
+		const gchar *title,
+		const gchar *text);
+void sn_set_tooltip_iconname(StatusNotifierItem *this, const gchar *iconname);
+void sn_set_tooltip_icondata(StatusNotifierItem *this, GdkPixbuf *pixbuf);
+void sn_set_tooltip_title(StatusNotifierItem *this, const gchar *title);
+void sn_set_tooltip_text(StatusNotifierItem *this, const gchar *text);
+
+const gchar* sn_get_id(StatusNotifierItem *this);
+const gchar* sn_get_title(StatusNotifierItem *this);
+const gchar* sn_get_icon_name(StatusNotifierItem *this);
+const gboolean sn_has_icon_pixmap(StatusNotifierItem *this);
+const gchar* sn_get_attention_icon_name(StatusNotifierItem *this);
+const gboolean sn_has_attention_icon_pixmap(StatusNotifierItem *this);
+const gchar* sn_get_overlay_icon_name(StatusNotifierItem *this);
+const gboolean sn_has_overlay_icon_pixmap(StatusNotifierItem *this);
+const gchar* sn_get_attention_movie_name(StatusNotifierItem *this);
+const gchar* sn_get_tooltip_iconname(StatusNotifierItem *this);
+const gboolean sn_has_tooltip_icondata(StatusNotifierItem *this);
+const gchar* sn_get_tooltip_title(StatusNotifierItem *this);
+const gchar* sn_get_tooltip_text(StatusNotifierItem *this);
+
+void sn_register_item(StatusNotifierItem *this);
+void sn_unregister(StatusNotifierItem *this);
+
+void sn_hook_on_context_menu(StatusNotifierItem *this, cb_context_menu cb);
+void sn_hook_on_activate(StatusNotifierItem *this, cb_activate cb);
+void sn_hook_on_secondary_activate(StatusNotifierItem *this, cb_secondary_activate cb);
+void sn_hook_on_scroll(StatusNotifierItem *this, cb_scroll cb);
+void sn_hook_on_registration_error(StatusNotifierItem *this, cb_registration_error cb, void *data, cb_destroy_regerr_data userdata_del_cb);
+
+
+#endif
diff -Naur a/scripts/configure_minimal.sh b/scripts/configure_minimal.sh
--- a/scripts/configure_minimal.sh	2015-10-13 04:35:03.162186804 +0000
+++ b/scripts/configure_minimal.sh	2015-10-13 04:33:19.775520860 +0000
@@ -1 +1 @@
-./configure --enable-maintainer-mode --disable-nullout --disable-oss --disable-sid --disable-ffap --disable-vtx --disable-adplug --disable-vorbis --disable-ffmpeg --disable-flac --disable-sndfile  --disable-wavpack --disable-cdda --disable-gme --disable-dumb --disable-musepack --disable-wildmidi --disable-tta --disable-dca --disable-aac --disable-mms --disable-shn --disable-ao --disable-supereq --disable-artwork --disable-lfm --disable-vfs-curl --disable-hotkeys --disable-notify --disable-shellexec
+./configure --enable-maintainer-mode --disable-nullout --disable-oss --disable-sid --disable-ffap --disable-vtx --disable-adplug --disable-vorbis --disable-ffmpeg --disable-flac --disable-sndfile  --disable-wavpack --disable-cdda --disable-gme --disable-dumb --disable-musepack --disable-wildmidi --disable-tta --disable-dca --disable-aac --disable-mms --disable-shn --disable-ao --disable-supereq --disable-artwork --disable-lfm --disable-vfs-curl --disable-hotkeys --disable-notify --disable-shellexec --disable-statusnotifier
diff -Naur a/scripts/portable_package_static.sh b/scripts/portable_package_static.sh
--- a/scripts/portable_package_static.sh	2015-10-13 04:35:03.162186804 +0000
+++ b/scripts/portable_package_static.sh	2015-10-13 04:33:19.775520860 +0000
@@ -80,6 +80,7 @@
     $PLUGDIR/pltbrowser_gtk2.so\
     $PLUGDIR/pltbrowser_gtk3.so\
     $PLUGDIR/in_sc68.so\
+    $PLUGDIR/statusnotifier.so\
     $PLUGDIR/data68\
     $PIXMAPDIR\
     $SRCDIR/locale\
diff -Naur a/scripts/portable_postbuild.sh b/scripts/portable_postbuild.sh
--- a/scripts/portable_postbuild.sh	2015-10-13 04:35:03.162186804 +0000
+++ b/scripts/portable_postbuild.sh	2015-10-13 04:33:19.775520860 +0000
@@ -41,7 +41,9 @@
 	 lastfm sid adplug sndfile artwork alac \
 	 supereq gme dumb notify musepack wildmidi \
 	 tta dca aac mms shn ao shellexec vfs_zip \
-	 m3u converter pulse dsp_libsrc mono2stereo wma ; do
+	 m3u converter pulse dsp_libsrc mono2stereo \
+	 wma statusnotifier \
+	 ; do
     if [ -f ./plugins/$i/.libs/$i.so ]; then
 		 cp ./plugins/$i/.libs/$i.so $PLUGDIR/
 	elif [ -f ./plugins/$i/$i.so ]; then
diff -Naur a/scripts/quickinstall.sh b/scripts/quickinstall.sh
--- a/scripts/quickinstall.sh	2015-10-13 04:35:03.162186804 +0000
+++ b/scripts/quickinstall.sh	2015-10-13 04:33:19.775520860 +0000
@@ -54,3 +54,4 @@
 cp ./plugins/pltbrowser/.libs/pltbrowser_gtk3.so $PREFIX/lib/deadbeef/
 cp ./plugins/coreaudio/.libs/coreaudio.so $PREFIX/lib/deadbeef/
 cp ./plugins/sc68/.libs/in_sc68.so $PREFIX/lib/deadbeef/
+cp ./plugins/statusnotifier/.libs/statusnotifier.so $PREFIX/lib/deadbeef/
